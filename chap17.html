<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	  <link rel="stylesheet" href="diveintopython.css" type="text/css">
      <link rev="made" href="mailto:johnsonj@dreamwiz.com">
      <meta name="generator" content="johnsonj">
      <meta name="description" content="다이빙 파이썬 번역.">
      <meta name="keywords" content="Python, Dive Into Python, tutorial, object-oriented, programming, documentation, book, free">
      <meta name="description" content="한글판">
   </head>
   <body>


<!-- Copyright  2005. Spidersoft Ltd -->
<style>
A.applink:hover {border: 2px dotted #DCE6F4;padding:2px;background-color:#ffff00;color:green;text-decoration:none}
A.applink       {border: 2px dotted #DCE6F4;padding:2px;color:#2F5BFF;background:transparent;text-decoration:none}
A.info          {color:#2F5BFF;background:transparent;text-decoration:none}
A.info:hover    {color:green;background:transparent;text-decoration:underline}
</style>
<div style='BORDER: 1px solid #DCE6F4; MARGIN-TOP: 20px; MARGIN-BOTTOM: 20px; MARGIN-LEFT: 5px; MARGIN-RIGHT: 5px; PADDING: 5px; BACKGROUND-COLOR: #eef8ff;line-height:180%; COLOR: #000000; font-family: Arial; font-size: 8pt; width=100%; FILTER: progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr="#FFFFFFFF", EndColorStr="#F2F5FAFF");'>
This page was saved using <a class="applink" href="http://www.spidersoft.com"><b>WebZIP 7.0.2.1028</b></a>  on  06/14/12  11:14:50.<br>
<b>Address:</b> <a class="info" href="http://coreapython.hosting.paran.com/dive/chap17.html">http://coreapython.hosting.paran.com/dive/chap17.html</a><br>
<b>Title:</b> 17. 동적인 함수 &nbsp;&bull;&nbsp; <b>Size:</b> 83065<br></div>
<!-- /Copyright  2005. Spidersoft Ltd -->


<TABLE class='headerOFcontent'>
<TR>
    <TD align="left"><A HREF="chap16.html">☜ 제 16 장 기능적 프로그래밍</A></TD>
    <TD align="center"><A HREF="chap00.html" title="목차로">"""  Dive Into Python  """<BR>다이빙 파이썬</A></TD>
    <TD align="right"><A HREF="chap18.html">제 18 장 수행성능 조율 ☞</A></TD>
</TR>
</TABLE>
		 <div name="17장" class="chapter" lang="en">
            <div class="titlepage">
               <div>
                  <div>
                     <h1 class="title"><a name="plural"></a>제&nbsp;17 장&nbsp;동적 함수
                     </h1>
                  </div>
               </div>
             </div>
         </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.divein"></a>17.1.&nbsp;뛰어들기                      </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>복수형에 대하여 연구해 보겠습니다. 또 기타 다른 함수와 고급 정규 표현식 그리고 발생자를 돌려주는 함수도 언급하고 싶습니다.  발생자(Generators)는 <span class="application">파이썬</span> 2.3에서 새로 도입되었습니다.  그러나 먼저 복수형을 만드는 방법에 관하여 연구해 봅시다.
                  </p>
               </div>
               <p>
			   아직 <a href="http://coreapython.hosting.paran.com/dive/chap07.html#re" title="Chapter&nbsp;7.&nbsp;Regular Expressions">제&nbsp;7 장 <i>정규표현식(Regular Expressions)</i></a>을 읽지 않았다면 지금이 좋은 때가 된 것 같군요.  이 장에서는 여러분이 정규 표현식을 기본적으로 알고 있다고 가정하고, 곧바로 보다 고급스런 사용법을 익혀 보겠습니다.
               </p>
               <p>
			   영어는 수 많은 언어로부터 빌려 온 정신분열적인 언어로서, 단수형을 복수형으로 바꾸는 규칙은 복잡하고 다양합니다.  먼저 규칙이 있고 다음 그런 규칙에 대한 예외가 있으며 그리고 그 예외에 대한 예외가 있습니다.
               </p>
               <p>영어로-말하는 나라에서 자랐거나 정규 교육 환경에서 영어를 배웠다면 아마도 기본적인 규칙을 잘 아실 것입니다:
               </p>
               <div class="orderedlist">
                  <ol type="1">
                     <li>단어가 S, X, 또는 Z로 끝나면 ES를 붙인다.  &#8220;<span class="quote">Bass</span>&#8221;는 &#8220;<span class="quote">basses</span>&#8221가 되고;, &#8220;<span class="quote">fax</span>&#8221;는 &#8220;<span class="quote">faxes</span>&#8221;가 되며, &#8220;<span class="quote">waltz</span>&#8221;는 &#8220;<span class="quote">waltzes</span>&#8221;가 된다.
                     </li>
                     <li>단어가 소리나는 H로 끝나면, ES를 붙인다; 묵음 H로 끝나면, 그냥 S를 붙인다.  소리나는 H란 무엇일까?  다른 글자와 조합되면 들을 수 있는 소리를 내는 것이다.  그래서 &#8220;<span class="quote">coach</span>&#8221;는 &#8220;<span class="quote">coaches</span>&#8221가 되고; &#8220;<span class="quote">rash</span>&#8221;는 &#8220;<span class="quote">rashes</span>&#8221;가 된다. 발음을 해 보면 CH와 SH 소리를 들을 수 있기 때문이다. 그러나 &#8220;<span class="quote">cheetah</span>&#8221;는 &#8220;<span class="quote">cheetahs</span>&#8221;가 되는데, H가 소리가 나지 않기 때문이다.
                     </li>
                     <li>Y로 끝나는 단어가 I처럼 소리나면 Y를 IES로 바꾼다; 그 Y가 다른 어떤 소리가 나는 모음과 결합하면 그냥 S를 붙인다.  그래서 &#8220;<span class="quote">vacancy</span>&#8221;는&#8220;<span class="quote">vacancies</span>&#8221;가  되지만 &#8220;<span class="quote">day</span>&#8221;는 &#8220;<span class="quote">days</span>&#8221;가 된다.
                     </li>
                     <li>다른 모든 것이 실패하면 그냥 S를 붙이고 잘되기를 기대한다.</li>
                  </ol>
               </div>
               <p>(물론, 예외가 많습니다.  &#8220;<span class="quote">Man</span>&#8221;은 &#8220;<span class="quote">men</span>&#8221;이 되고 &#8220;<span class="quote">woman</span>&#8221;은 &#8220;<span class="quote">women</span>&#8221;이 되지만 &#8220;<span class="quote">human</span>&#8221;은 &#8220;<span class="quote">humans</span>&#8221;가 됩니다.  &#8220;<span class="quote">Mouse</span>&#8221;는 &#8220;<span class="quote">mice</span>&#8221;가 되고 &#8220;<span class="quote">louse</span>&#8221;는 &#8220;<span class="quote">lice</span>&#8221;가 되지만 &#8220;<span class="quote">house</span>&#8221;는 &#8220;<span class="quote">houses</span>&#8221;가 됩니다.  &#8220;<span class="quote">Knife</span>&#8221;는 &#8220;<span class="quote">knives</span>&#8221;가 되고 &#8220;<span class="quote">wife</span>&#8221;는 &#8220;<span class="quote">wives</span>&#8221;가 되지만 &#8220;<span class="quote">lowlife</span>&#8221;는 &#8220;<span class="quote">lowlifes</span>&#8221;가 됩니다. 따로 복수형을 가진 단어인 &#8220;<span class="quote">sheep</span>&#8221;와 &#8220;<span class="quote">deer</span>&#8221; 그리고 &#8220;<span class="quote">haiku</span>&#8221;는 더 이상 언급하지 않겠습니다.)
               </p>
               <p>물론 다른 언어들은 완전히 다릅니다.</p>
               <p>명사를 복수형으로 만드는 모듈을 디자인해 봅시다. 먼저 영어 명사로 시작하고 그저 이 네 가지 규칙만으로 시작하지만 반드시 규칙을 더 추가할 필요가 있다는 사실을 꼭 명심합시다. 그리고 결국 언어를 더 추가할 필요가 있을 것입니다.
               </p>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage1"></a>17.2.&nbsp;<tt class="filename">plural.py</tt>, 1 단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>
				  그래서 단어들을 유심히 살펴보시면 적어도 영어로 구성된 문자열일 뿐입니다. 다양하게 조합된 문자를 찾아서, 각각을 다르게 처리해야 한다는 규칙이 있습니다. 이런 작업은 아무래도 정규 표현식으로 처리해야 할 듯 싶습니다.
                  </p>
               </div>
               <div class="example"><a name="d0e37108"></a><h3 class="title">예제&nbsp;17.1.&nbsp;<tt class="filename">plural1.py</tt></h3><pre class="programlisting">
import re

def plural(noun):                            
    if re.search('[sxz]$', noun):             <a name="plural.stage1.1.1"></a><span class="round">①</span>
        return re.sub('$', 'es', noun)        <a name="plural.stage1.1.2"></a><span class="round">②</span>
    elif re.search('[^aeioudgkprt]h$', noun):
        return re.sub('$', 'es', noun)       
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:                                    
        return noun + 's'                    
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.1.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">좋습니다. 이것은 정규 표현식입니다. 그러나 <a href="http://coreapython.hosting.paran.com/dive/chap07.html#re" title="Chapter&nbsp;7.&nbsp;Regular Expressions">제&nbsp;7장, <i>정규 표현식</i></a>에서 보지 못했던 구문을 사용합니다. 각괄호는 &#8220;<span class="quote">정확하게 이 문자중 하나에 부합한다는 뜻입니다</span>&#8221;.  그래서 <tt class="literal">[sxz]</tt>는 &#8220;<span class="quote"><tt class="literal">s</tt>나 <tt class="literal">x</tt> 또는 <tt class="literal">z</tt>이지만 그 중에 하나</span>&#8221;라는 뜻입니다.  <tt class="literal">$</tt>는 알고 계실 겁니다; 문자열의 끝에 일치합니다. 그래서 <tt class="varname">noun</tt>이 <tt class="literal">s</tt>나 <tt class="literal">x</tt> 또는 <tt class="literal">z</tt>로 끝나는지 점검합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.1.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">이 <tt class="function">re.sub</tt> 함수는 정규 표현식 기반의 문자열 교체를 수행합니다.  좀 더 자세하게 살펴보겠습니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="d0e37161"></a><h3 class="title">예제&nbsp;17.2.&nbsp;<tt class="function">re.sub</tt> 소개</h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">import re</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.search('[abc]', 'Mark')</span>   <a name="plural.stage1.2.1"></a><span class="round">①</span>
<span class="computeroutput">&lt;_sre.SRE_Match object at 0x001C1FA8&gt;</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('[abc]', 'o', 'Mark')</span> <a name="plural.stage1.2.2"></a><span class="round">②</span>
<span class="computeroutput">'Mork'</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('[abc]', 'o', 'rock')</span> <a name="plural.stage1.2.3"></a><span class="round">③</span>
<span class="computeroutput">'rook'</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('[abc]', 'o', 'caps')</span> <a name="plural.stage1.2.4"></a><span class="round">④</span>
<span class="computeroutput">'oops'</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.2.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">문자열 <tt class="literal">Mark</tt>에 <tt class="literal">a</tt>나 <tt class="literal">b</tt> 또는 <tt class="literal">c</tt>가 포함되어 있습니까?  예, <tt class="literal">a</tt>가 포함되어 있습니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.2.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">좋습니다. 이제 <tt class="literal">a</tt>나 <tt class="literal">b</tt> 또는 <tt class="literal">c</tt>를 찾아 <tt class="literal">o</tt>로 교체하겠습니다.  <tt class="literal">Mark</tt>는 <tt class="literal">Mork</tt>가 됩니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.2.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left">같은 함수는 <tt class="literal">rock</tt>을 <tt class="literal">rook</tt>으로 바꿉니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.2.4"><span class="round">④</span></a> 
                           </td>
                           <td valign="top" align="left">이 함수가 <tt class="literal">caps</tt>를 <tt class="literal">oaps</tt>로 바꿀 것 같아 보이지만 그렇지 않습니다.  <tt class="literal">re.sub</tt>는 부합한 <span class="emphasis"><em>모든 것들을 교체합니다</em></span>. 첫 번째만 교체하는 것이 아닙니다. 그래서 이 정규 표현식은 <tt class="literal">caps</tt>를 <tt class="literal">oops</tt>로 바꾸는데, 왜냐하면 <tt class="literal">c</tt>와 <tt class="literal">a</tt> 모두 <tt class="literal">o</tt>로 바뀌기 때문입니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="d0e37292"></a><h3 class="title">예제&nbsp;17.3.&nbsp;<tt class="filename">plural1.py</tt>로 다시</h3><pre class="programlisting">
import re

def plural(noun):                            
    if re.search('[sxz]$', noun):            
        return re.sub('$', 'es', noun)        <a name="plural.stage1.3.1"></a><span class="round">①</span>
    elif re.search('[^aeioudgkprt]h$', noun): <a name="plural.stage1.3.2"></a><span class="round">②</span>
        return re.sub('$', 'es', noun)        <a name="plural.stage1.3.3"></a><span class="round">③</span>
    elif re.search('[^aeiou]y$', noun):      
        return re.sub('y$', 'ies', noun)     
    else:                                    
        return noun + 's'                    
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.3.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">plural</tt> 함수로 되돌아가 보겠습니다. 무엇을 하고 있습니까?  문자열의 끝을 <tt class="literal">es</tt>로 바꾸고 있습니다. 다른 말로 하면 문자열에 <tt class="literal">es</tt>를 추가합니다. 문자열 결합으로 같은 일을 달성할 수 있습니다. 예를 들면 <tt class="literal">noun + 'es'</tt>와 같이 말입니다. 그러나 나는 일관성있게 무엇에나 정규 표현식을 사용합니다. 그 이유는 이 장의 후반부에서 가르쳐 드리겠습니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.3.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">자세하게 살펴보세요. 이는 또다른 변형입니다. 각괄호 안의 첫 문자인 <tt class="literal">^</tt>는 뭔가 특별한 뜻이 있습니다: 부인이라는 뜻이 있는데,  <tt class="literal">[^abc]</tt>는 &#8220; <span class="emphasis"></span> <tt class="literal">a</tt><em>만 제외하고</em> <span class="quote">어떤 문자이든 한 문자나 <tt class="literal">b</tt> 또는 <tt class="literal">c</tt></span>&#8221;라는 뜻입니다. 그래서 <tt class="literal">[^aeioudgkprt]</tt>는 <tt class="literal">a</tt>를 제외하고 아무 문자 하나, <tt class="literal">e</tt>, <tt class="literal">i</tt>, <tt class="literal">o</tt>, <tt class="literal">u</tt>, <tt class="literal">d</tt>, <tt class="literal">g</tt>, <tt class="literal">k</tt>, <tt class="literal">p</tt>, <tt class="literal">r</tt>, 또는 <tt class="literal">t</tt>라는 뜻입니다. 다음 그 문자 다음에 <tt class="literal">h</tt>가 따르고, 그 뒤에 문자열의 끝이 따라야 합니다. H로 끝나고 발음이 되는 단어를 찾고 있습니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.3.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left">여기도 같은 패턴입니다: Y로 끝나는 단어에 일치하며, Y 앞의 문자는 <tt class="literal">a</tt>, <tt class="literal">e</tt>, <tt class="literal">i</tt>, <tt class="literal">o</tt>, 또는 <tt class="literal">u</tt>가 <span class="emphasis"><em>아닙니다</em></span>.  Y로 끝나면 I처럼 소리나는 단어를 찾고 있습니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="d0e37404"></a><h3 class="title">예제&nbsp;17.4.&nbsp;부인 정규 표현식 심화연구</h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">import re</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.search('[^aeiou]y$', 'vacancy')</span> <a name="plural.stage1.4.1"></a><span class="round">①</span>
<span class="computeroutput">&lt;_sre.SRE_Match object at 0x001C1FA8&gt;</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.search('[^aeiou]y$', 'boy')</span>     <a name="plural.stage1.4.2"></a><span class="round">②</span>
<tt class="prompt">&gt;&gt;&gt; </tt>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.search('[^aeiou]y$', 'day')</span>
<tt class="prompt">&gt;&gt;&gt; </tt>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.search('[^aeiou]y$', 'pita')</span>    <a name="plural.stage1.4.3"></a><span class="round">③</span>
<tt class="prompt">&gt;&gt;&gt; </tt>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.4.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">vacancy</tt>는 이 정규 표현식에 부합하는데, <tt class="literal">cy</tt>로 끝나며, <tt class="literal">c</tt>는 <tt class="literal">a</tt>, <tt class="literal">e</tt>, <tt class="literal">i</tt>, <tt class="literal">o</tt>, 또는 <tt class="literal">u</tt>가 아니기 때문입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.4.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">boy</tt>는 일치하지 않습니다. 왜냐하면 <tt class="literal">oy</tt>로 끝나며, <tt class="literal">y</tt> 앞의 문자는 <tt class="literal">o</tt>가 되면 안된다고 구체적으로 지정했기 때문입니다.  <tt class="literal">day</tt>는 일치하지 않습니다. 왜냐하면 <tt class="literal">ay</tt>로 끝나기 때문입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.4.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">pita</tt>는 일치하지 않습니다. 왜냐하면 <tt class="literal">y</tt>로 끝나지 않기 때문입니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="d0e37507"></a><h3 class="title">예제&nbsp;17.5.&nbsp; <tt class="function">re.sub</tt> 심화연구</h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('y$', 'ies', 'vacancy')</span>              <a name="plural.stage1.5.1"></a><span class="round">①</span>
<span class="computeroutput">'vacancies'</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('y$', 'ies', 'agency')</span>
<span class="computeroutput">'agencies'</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">re.sub('([^aeiou])y$', r'\1ies', 'vacancy')</span> <a name="plural.stage1.5.2"></a><span class="round">②</span>
<span class="computeroutput">'vacancies'</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.5.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">이 정규 표현식은 <tt class="literal">vacancy</tt>를 <tt class="literal">vacancies</tt>로 바꾸고 <tt class="literal">agency</tt>를 <tt class="literal">agencies</tt>로 바꾸는데, 이것이 바로 원하던 바입니다. 주의하세요. <tt class="literal">boy</tt>도 <tt class="literal">boies</tt>로 바뀔 것 같지만 함수 안에서 이런 일은 일어나지 않습니다. 왜냐하면 <tt class="function">re.sub</tt>를 수행해도 되는지 알아 보기 위해 먼저 <tt class="function">re.search</tt>를 실행했기 때문입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage1.5.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">지나가는 길에, 지적하고 싶은 것이 있습니다. (하나는 규칙이 적용되는지 알아보고 또 하나는 실제로 적용하는) 이 두 정규 표현식을 하나의 정규 표현식으로 결합하는 것도 가능합니다. 이렇게 보일 겁니다. 거의 비슷하게 보입니다: <tt class="literal">y</tt> 앞의 문자를 기억하기 위해, <a href="http://coreapython.hosting.paran.com/dive/chap07.html#re.phone" title="7.6.&nbsp;Case study: Parsing Phone Numbers">섹션&nbsp;7.6, &#8220;사례 연구: 전화 번호 해석하기&#8221;</a> 에서 배운, 기억된 그룹(remembered group)을 사용하고 있습니다. 다음 교체 문자열에서, 새로운 구문인 <tt class="literal">\1</tt>를 사용하고 있는데, 이는 &#8220;<span class="quote">이봐, 기억해 놓은 첫 그룹 있지? 여기에다 두라구</span>&#8221;라는 뜻입니다. 이 경우, <tt class="literal">y</tt> 앞에 <tt class="literal">c</tt>를 기억하고 있으며, 교체할 때 <tt class="literal">c</tt> 대신에 <tt class="literal">c</tt>를, 그리고 <tt class="literal">y</tt> 자리에 <tt class="literal">ies</tt>로 교체합니다.  (기억된 그룹이 하나 이상이라면 <tt class="literal">\2</tt>와 <tt class="literal">\3</tt> 그리고 등등을 사용할 수 있습니다.)
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>정규 표현식 교체는 아주 강력합니다. <tt class="literal">\1</tt> 구문은 더욱 더 강력합니다. 그러나 전체 연산을 하나의 정규 표현식으로 조합하면 또한 더 읽기 어려워지고, 처음에 기술한 복수화 규칙에 직접적으로 일치되지 않습니다. 원래는 &#8220;<span class="quote">단어가 S나 X 또는 Z로 끝나면 ES</span>를 추가하라&#8221;와 같은 규칙을 설계했었습니다. 이 함수를 살펴보면 두 줄의 코드로 &#8220;<span class="quote">단어가 S나 X 또는 Z로 끝나면 ES</span>를 추가하라&#8221;고 서술합니다.  이 보다 더 직접적일 수는 없습니다.
               </p>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage2"></a>17.3.&nbsp;<tt class="filename">plural.py</tt>, 2 단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>이제 추상화 수준을 추가해 보겠습니다. 규칙 목록을 정의하면서 시작했습니다: 이러면 저렇게 하고, 그렇지 않으면 다음 규칙으로 가라. 추상화 부분을 간단하게 만들기 위해 프로그램의 일부를 잠시 복잡하게 만들어 보겠습니다.
                  </p>
               </div>
               <div class="example"><a name="d0e37629"></a><h3 class="title">예제&nbsp;17.6.&nbsp;<tt class="filename">plural2.py</tt></h3><pre class="programlisting">
import re

def match_sxz(noun):                          
    return re.search('[sxz]$', noun)          

def apply_sxz(noun):                          
    return re.sub('$', 'es', noun)            

def match_h(noun):                            
    return re.search('[^aeioudgkprt]h$', noun)

def apply_h(noun):                            
    return re.sub('$', 'es', noun)            

def match_y(noun):                            
    return re.search('[^aeiou]y$', noun)      
        
def apply_y(noun):                            
    return re.sub('y$', 'ies', noun)          

def match_default(noun):                      
    return 1                                  
        
def apply_default(noun):                      
    return noun + 's'                         

rules = ((match_sxz, apply_sxz),
         (match_h, apply_h),
         (match_y, apply_y),
         (match_default, apply_default)
         )                                     <a name="plural.stage2.1.1"></a><span class="round">①</span>

def plural(noun):                             
    for matchesRule, applyRule in rules:       <a name="plural.stage2.1.2"></a><span class="round">②</span>
        if matchesRule(noun):                  <a name="plural.stage2.1.3"></a><span class="round">③</span>
            return applyRule(noun)             <a name="plural.stage2.1.4"></a><span class="round">④</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage2.1.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">이 버전은 더 복잡해 보입니다 (분명히 더 깁니다). 그러나 정확하게 같은 일을 합니다: 네 가지 다른 규칙을 순서대로 일치시켜 보고 부합되면 적절한 정규 표현식을 적용합니다. 차이점은 일치 규칙과 적용 규칙마다 따로따로 자신만의 함수에 정의된다는 것입니다. 그리고 그 함수들은 이 <tt class="varname">rules</tt> 변수에 나열되는데, 이 변수는 터플로 구성된 터플입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage2.1.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">for</tt> 회돌이를 사용하면 <tt class="varname">rules</tt> 터플로부터 일치 규칙과 적용 규칙을 한 번에 두 개(일치규칙, 적용규칙)를 끌어낼 수 있습니다. <tt class="literal">for</tt> 회돌이의 첫 회전에서, <tt class="varname">matchesRule</tt>는 <tt class="function">match_sxz</tt>를 얻고, <tt class="varname">applyRule</tt>는 <tt class="function">apply_sxz</tt>를 얻습니다.  두 번째 돌때 (여기까지 성공했다고 간주한다면), <tt class="varname">matchesRule</tt>에는 <tt class="function">match_h</tt>가 할당되고, <tt class="varname">applyRule</tt>은 <tt class="function">apply_h</tt>가 할당됩니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage2.1.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><a href="http://coreapython.hosting.paran.com/dive/chap02.html#odbchelper.objects" title="2.4.&nbsp;Everything Is an Object"><span class="application">파이썬</span>에서는 모든 것이, 함수조차도 객체라는</a> 사실을 기억하세요.  <tt class="varname">rules</tt>에는 실체 함수가 담겨 있습니다; 함수의 이름이 아니라 실제 함수입니다. <tt class="literal">for</tt> 회돌이에서 할당되면 <tt class="varname">matchesRule</tt>와 <tt class="varname">applyRule</tt>은 실제로 호출할 수 있는 함수입니다. 그래서 <tt class="literal">for</tt> 회돌이의 첫 회전에서, 이는 <tt class="function">matches_sxz(noun)</tt>을 호출한 것과 동등합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage2.1.4"><span class="round">④</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">for</tt> 회돌이의 첫 회전에서, 이는 <tt class="function">apply_sxz(noun)</tt>를 호출한 것과 동등합니다. 등등.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>이렇게 추가된 추상화 수준이 이해가 가지 않는다면 과연 같은지 함수를 풀어서 알아 보겠습니다. 이 <tt class="literal">for</tt> 회돌이는 다음과 동등합니다:
               </p>
               <div class="example"><a name="d0e37727"></a><h3 class="title">예제&nbsp;17.7.&nbsp;<tt class="function">plural</tt> 함수 펼쳐 보기
                  </h3><pre class="programlisting">
def plural(noun):
    if match_sxz(noun):
        return apply_sxz(noun)
    if match_h(noun):
        return apply_h(noun)
    if match_y(noun):
        return apply_y(noun)
    if match_default(noun):
        return apply_default(noun)
</pre></div>
               <p>여기에서 이점은 <tt class="function">plural</tt> 함수가 이제 단순해진다는 것입니다. 다른 곳에 정의된 규칙 리스트를 받아서, 일반적인 형태로 그 규칙들을 반복합니다. 일치 규칙을 얻으면; 일치되었는가?  그러면 적용 규칙을 호출합니다. 규칙은 어느 곳이든 어떤 방식으로든 정의될 수 있습니다. <tt class="function">plural</tt> 함수는 그에 개의치 않습니다.
               </p>
               <p>이제, 이 추상화 수준을 추가한 가치가 있는가? 음, 아직은 아닙니다. 함수에 새로운 규칙을 추가해야 한다고 생각해 봅시다. 자, 앞 예제에서, <tt class="literal">if</tt> 서술문을 <tt class="function">plural</tt>  함수에 추가할 필요가 있었습니다. 이 예제에서는 두가지 함수 <tt class="function">match_foo</tt>와 <tt class="function">apply_foo</tt>를 추가할 필요가 있고, 다음 <tt class="varname">rules</tt> 리스트를 갱신하여 새로운 일치 함수와 적용 함수가 다른 규칙에 상대적으로 호출되어야 할 순서를 지정할 필요가 있습니다.
               </p>
               <p>이것이 바로 다음 섹션으로 나아갈 모퉁이 돌입니다. 다음 섹션으로 갑시다.</p>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage3"></a>17.4.&nbsp;<tt class="filename">plural.py</tt>, 3  단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>실제로는 일치마다 그에 맞게 이름을 붙여 따로 함수를 정의할 필요는 없습니다. 직접적으로 호출하지 않습니다; <tt class="varname">rules</tt> 리스트에 정의해 두고 그를 통하여 호출합니다. 그런 함수들을 익명화함으로써 규칙 정의를 날씬하게 만들어 보겠습니다.
                  </p>
               </div>
               <div class="example"><a name="d0e37775"></a><h3 class="title">예제&nbsp;17.8.&nbsp;<tt class="filename">plural3.py</tt></h3><pre class="programlisting">
import re

rules = \
  (
    (
     lambda word: re.search('[sxz]$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeioudgkprt]h$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeiou]y$', word),
     lambda word: re.sub('y$', 'ies', word)
    ),
    (
     lambda word: re.search('$', word),
     lambda word: re.sub('$', 's', word)
    )
   )                                           <a name="plural.stage3.1.1"></a><span class="round">①</span>

def plural(noun):                             
    for matchesRule, applyRule in rules:       <a name="plural.stage3.1.2"></a><span class="round">②</span>
        if matchesRule(noun):                 
            return applyRule(noun)            
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage3.1.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">이는 2 단계에서 정의한 것과 똑 같은 규칙 세트입니다. 유일한 차이점은 <tt class="function">match_sxz</tt>와 <tt class="function">apply_sxz</tt> 같이 이름붙여 함수를 정의하는 대신에, 그런 함수 정의를 직접적으로 <tt class="varname">rules</tt> 리스트 안에 &#8220;<span class="quote">집어 넣는다</span>&#8221;는 것입니다. <a href="http://coreapython.hosting.paran.com/dive/chap04.html#apihelper.lambda" title="4.7.&nbsp;Using lambda Functions">람다 함수</a>를 사용해서 말입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage3.1.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">plural</tt> 함수는 전혀 바뀌지 않았음에 주목하세요. 규칙 함수 세트를 반복하면서, 첫 규칙을 점검해서 참 값을 돌려주면 두 번째 규칙을 호출하고 그 값을 돌려줍니다. 말 그대로 위와 같습니다. 유일한 차이점은 규칙 함수가 람다 함수를 사용하여 익명으로 인라인으로 정의되었다는 것입니다.  그러나 <tt class="function">plural</tt> 함수는 규칙이 어떻게 정의되어 있든지 상관하지 않습니다; 그저 규칙 리스트를 얻어서 맹목적으로 반복할 뿐입니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>이제 새로운 규칙을 얻으려면 규칙을 직접적으로 <tt class="varname">rules</tt> 리스트에 정의하면 됩니다: 하나는 일치 규칙이고 또 하나는 적용 규칙입니다. 그러나 규칙 함수를 이런 식으로 인라인으로 정의하면  여기에 불필요하게 중복이 있다는 사실이 더욱 확실하게 드러납니다.  네쌍의 함수가 있으며, 모두 같은 패턴을 따릅니다. match 함수는 <tt class="function">re.search</tt>를 한 번만 호출하고, apply 함수는 <tt class="function">re.sub</tt>를 한 번 호출합니다. 이런 유사점들을 공통 인수로 추출해 봅시다.
               </p>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage4"></a>17.5.&nbsp;<tt class="filename">plural.py</tt>, 4 단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>새로운 규칙을 더 쉽게 정의할 수 있도록 코드의 중복을 인수분해해 봅시다.</p>
               </div>
               <div class="example"><a name="plural.stage4.example.1"></a><h3 class="title">예제&nbsp;17.9.&nbsp;<tt class="filename">plural4.py</tt></h3><pre class="programlisting">
import re

def buildMatchAndApplyFunctions((pattern, search, replace)):  
    matchFunction = lambda word: re.search(pattern, word)      <a name="plural.stage4.1.1"></a><span class="round">①</span>
    applyFunction = lambda word: re.sub(search, replace, word) <a name="plural.stage4.1.2"></a><span class="round">②</span>
    return (matchFunction, applyFunction)                      <a name="plural.stage4.1.3"></a><span class="round">③</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.1.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">buildMatchAndApplyFunctions</tt> 함수는 다른 함수들을 동적으로 구축합니다. 이 함수는 <tt class="varname">pattern</tt>과 <tt class="varname">search</tt> 그리고 <tt class="varname">replace</tt>를 받습니다 (실제로는 터플을 받지만 잠시 후에 더 자세히 설명합니다). <tt class="literal">lambda</tt> 구문을 사용하여 매개변수 하나 (<tt class="varname">word</tt>)를 받는 함수로 일치 함수를 구축할 수 있습니다. <tt class="function">buildMatchAndApplyFunctions</tt>에 건넨 <tt class="varname">pattern</tt> 그리고 구축되어 있는 일치 함수에 건넨 <tt class="varname">word</tt>를 가지고 <tt class="function">re.search</tt>를 호출합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.1.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">적용 함수를 구축하는 것도 비슷하게 작동합니다. 적용 함수는 매개변수를 하나 받아, <tt class="function">buildMatchAndApplyFunctions</tt> 함수에 건넨 <tt class="varname">search</tt> 매개변수와 <tt class="varname">replace</tt> 매개변수 그리고 구축중인 적용 함수에 건넨 <tt class="varname">word</tt>를 가지고 <tt class="function">re.sub</tt>를 호출하는 함수입니다. 바깥 매개변수의 값을 동적 함수 안에 사용하는 이 테크닉을 클로저(<span class="emphasis"><em>closures</em></span>)라고 부릅니다. 구축하고 있는 적용 함수 안에 상수를 본질적으로 정의하고 있습니다: 하나의 매개변수(<tt class="varname">word</tt>)를 받지만 그와 더불어 적용 함수를 정의할 때 설정된 다른 두 값(<tt class="varname">search</tt>와 <tt class="varname">replace</tt>)에도 작용합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.1.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left">마지막으로, <tt class="function">buildMatchAndApplyFunctions</tt> 함수는 값이 두 개인 터플을 하나 돌려줍니다: 방금 만든 두 개의 함수가 그것입니다. 그런 함수 안에 정의한 상수는 (<tt class="varname">matchFunction</tt>안의 <tt class="varname">pattern</tt> 그리고 <tt class="varname">applyFunction</tt> 안의 <tt class="varname">search</tt>와 <tt class="varname">replace</tt>) 그런 함수와 함께 존재하며, 심지어 <tt class="function">buildMatchAndApplyFunctions</tt>으로부터 돌아온 후에도 존재합니다. 정말 멋집니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>이것이 정말 이해가 가지 않는다면 (그럴 겁니다. 괴이하지요), 사용법을 보시면 더 이해가 잘 가실 겁니다.</p>
               <div class="example"><a name="d0e37935"></a><h3 class="title">예제&nbsp;17.10.&nbsp;<tt class="filename">plural4.py</tt> 계속
                  </h3><pre class="programlisting">
patterns = \
  (
    ('[sxz]$', '$', 'es'),
    ('[^aeioudgkprt]h$', '$', 'es'),
    ('(qu|[^aeiou])y$', 'y$', 'ies'),
    ('$', '$', 's')
  )                                                 <a name="plural.stage4.2.1"></a><span class="round">①</span>
rules = map(buildMatchAndApplyFunctions, patterns)  <a name="plural.stage4.2.2"></a><span class="round">②</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.2.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">복수화 규칙은 이제 (함수가 아니라) 일련의 문자열로 정의됩니다. 첫 문자열은 <tt class="function">re.search</tt>에서 이 규칙이 일치하는지 알아 보는데 사용할 정규 표현식입니다; 두 번째와 세번째 문자열은 검색과 치환 표현식으로서 <tt class="function">re.sub</tt>에서 실제로 그 규칙을 적용하여 명사를 복수형으로 바꾸는데 사용합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.2.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">이 줄은 마법의 줄입니다. <tt class="varname">patterns</tt>에 문자열 리스트를 받아 그를 함수 리스트로 바꿉니다. 어떻게?  그 문자열들을 <tt class="function">buildMatchAndApplyFunctions</tt> 함수에 짝지어 주면 되는데, 세 개의 문자열을 매개변수로 취하고 두 함수를 담은 터플을 돌려줍니다. 이는 <tt class="varname">rules</tt>가 결국 앞의 예제와 정확하게 똑 같다는 뜻입니다: 터플 리스트로서, 각 터플은 함수 쌍이며, 첫 함수는 match 함수로서 <tt class="function">re.search</tt>를 호출하고 두 번째 함수는 apply 함수로서 <tt class="function">re.sub</tt>를 호출합니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>맹세하건대 제가 지어낸 것이 아닙니다: <tt class="varname">rules</tt>는 결국 앞의 예제와 정확하게 똑 같은 함수 리스트입니다. 
			   
			   <tt class="varname">rules</tt> 정의를 늘어놓아 보면 다음과 같습니다:
               </p>
               <div class="example"><a name="d0e37982"></a><h3 class="title">예제&nbsp;17.11.&nbsp;규칙 정의 펼쳐보기</h3><pre class="programlisting">
rules = \
  (
    (
     lambda word: re.search('[sxz]$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeioudgkprt]h$', word),
     lambda word: re.sub('$', 'es', word)
    ),
    (
     lambda word: re.search('[^aeiou]y$', word),
     lambda word: re.sub('y$', 'ies', word)
    ),
    (
     lambda word: re.search('$', word),
     lambda word: re.sub('$', 's', word)
    )
   )                                          
</pre></div>
               <div class="example"><a name="plural.finishing.up"></a><h3 class="title">예제&nbsp;17.12.&nbsp;<tt class="filename">plural4.py</tt>, 마무리
                  </h3><pre class="programlisting">
def plural(noun):                                  
    for matchesRule, applyRule in rules:            <a name="plural.stage4.3.1"></a><span class="round">①</span>
        if matchesRule(noun):                      
            return applyRule(noun)                 
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.3.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="varname">rules</tt> 리스트는 앞 예제와 똑같기 때문에, <tt class="function">plural</tt> 함수가 하나도 바뀌지 않아도 별로 놀랍지 않습니다. 기억하세요. 완전히 포괄적입니다; 규칙 함수 리스트를 받아서 순서대로 그를 호출합니다. 규칙이 어떻게 정의되어 있는지 신경쓰지 않습니다. <a href="#plural.stage2" title="17.3.&nbsp;plural.py, stage 2">단계 2</a>에서, 규칙은 별도로 이름붙은 함수로 정의되었습니다.  <a href="#plural.stage3" title="17.4.&nbsp;plural.py, stage 3">단계 3</a>에서는 익명의 <tt class="literal">lambda</tt> 함수로 정의되었습니다. 이제 단계 4에서는 <tt class="function">buildMatchAndApplyFunctions</tt> 함수를 날 문자열 리스트 위에 짝지어서 동적으로 구축됩니다. 아무 문제가 되지 않습니다; <tt class="function">plural</tt> 함수는 여전히 똑같은 방식으로 작동합니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>이 정도로도 충분히 놀랍지 않았다면 <tt class="function">buildMatchAndApplyFunctions</tt> 정의에 미묘하게 빼 놓은게 있다고 솔직히 고백해야겠습니다.
               </p>
               <div class="example"><a name="d0e38026"></a><h3 class="title">예제&nbsp;17.13.&nbsp;다시 한 번 <tt class="function">buildMatchAndApplyFunctions</tt> 살펴보기</h3><pre class="programlisting">
def buildMatchAndApplyFunctions((pattern, search, replace)):   <a name="plural.stage4.4.1"></a><span class="round">①</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.4.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">이중 괄호가 보이십니까?  이 함수는 실제로는 세 개의 매개변수를 받지 않습니다; 실제로는 한 개의 매개변수, 즉 세 개의 원소를 가진 터플을 하나 받습니다. 그러나 그 터플은 함수가 호출될 때 확장되고, 터플 안의 세 원소는 각각 다른 변수에 할당됩니다: <tt class="varname">pattern</tt>와 <tt class="varname">search</tt> 그리고 <tt class="varname">replace</tt>에 할당됩니다. 아직 잘 모르시겠다고요?  실제로 작동하는 모습을 살펴봅시다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="d0e38048"></a><h3 class="title">예제&nbsp;17.14.&nbsp;함수를 호출할 때 터플 확장하기</h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">def foo((a, b, c)):</span>
<tt class="prompt">...     </tt><span class="userinput">print c</span>
<tt class="prompt">...     </tt><span class="userinput">print b</span>
<tt class="prompt">...     </tt><span class="userinput">print a</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">parameters = ('apple', 'bear', 'catnap')</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">foo(parameters)</span> <a name="plural.stage4.5.1"></a><span class="round">①</span>
<span class="computeroutput">catnap</span>
<span class="computeroutput">bear</span>
<span class="computeroutput">apple</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage4.5.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">foo</tt> 함수를 적절하게 호출하려면 세 개의 원소를 가진 터플을 가지고 호출해야 합니다. 함수가 호출되면 원소들은 <tt class="function">foo</tt> 안에 있는 지역 변수에 따로따로 할당됩니다.
                           </td>
                        </tr>
                     </table>
                  </div>
                  <p>이제 되돌아가 왜 이 자동--터플-확장 트릭이 필요했는지 살펴보겠습니다.  <tt class="varname">patterns</tt>는 터플이 담긴 리스트였습니다. 그리고 각 터플은 세개의 원소를 가집니다. <tt class="literal">map(buildMatchAndApplyFunctions, patterns)</tt>를 호출하면 그것은 <tt class="function">buildMatchAndApplyFunctions</tt>가 세걔의 매개변수를 가지고 호출되지 <span class="emphasis"><em>않는다</em></span>는 뜻입니다. <tt class="function">map</tt>을 사용하여 리스트를 함수에 짝지으면 언제나 그 함수는 매개변수 하나로 호출됩니다: 리스트의 각 원소가 매개변수가 됩니다.  <tt class="varname">patterns</tt>의 경우, 리스트의 각 원소는 터플입니다. 그래서 <tt class="function">buildMatchAndApplyFunctions</tt>는 언제나 그 터플을 가지고 호출됩니다. 그리고 자동-터플-확장 트릭을 <tt class="function">buildMatchAndApplyFunctions</tt>의 정의에 사용하면 그 터플의 원소들을 이름붙은 변수에 할당하여 그 변수들을 가지고 작업할 수 있습니다.
                  </p>
               </div>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage5"></a>17.6.&nbsp;<tt class="filename">plural.py</tt>, 5 단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>중복된 코드를 모두 공통인수로 추출했으며 충분하게 추상화 수준을 추가하여 복수화 규칙을 문자열 리스트로 정의할 수 있었습니다. 다음 논리적 단계는 이런 문자열들을 받아서 별도의 파일에 두는 것입니다. 규칙을 사용하는 코드와 별도로 규칙을 파일에 따로 관리할 수 있습니다. 
                  </p>
               </div>
               <p>먼저, 원하는 규칙을 텍스트 파일에 담아 봅시다. 데이터 구조는 평범해서, 그냥 공간문자로- (또는 탭문자로-) 나뉜 문자열로서 세 개의 컬럼으로 구성됩니다.  파일 이름은 <tt class="filename">rules.en</tt>이며; &#8220;<span class="quote">en</span>&#8221;은 영어를 뜻합니다. 이 규칙들은 영어 명사를 복수화하는 규칙입니다. 나중에 다른 언어에 다른 규칙을 추가할 수 있습니다.
               </p>
               <div class="example"><a name="d0e38148"></a><h3 class="title">예제&nbsp;17.15.&nbsp;<tt class="filename">rules.en</tt></h3><pre class="programlisting">
[sxz]$                  $               es
[^aeioudgkprt]h$        $               es
[^aeiou]y$              y$              ies
$                       $               s
</pre></div>
               <p>이제 이 규칙 파일을 어떻게 사용할 수 있는지 살펴보겠습니다.</p>
               <div class="example"><a name="d0e38156"></a><h3 class="title">예제&nbsp;17.16.&nbsp;<tt class="filename">plural5.py</tt></h3><pre class="programlisting">
import re
import string                                                                     

def buildRule((pattern, search, replace)):                                        
    return lambda word: re.search(pattern, word) and re.sub(search, replace, word) <a name="plural.stage5.1.1"></a><span class="round">①</span>

def plural(noun, language='en'):                             <a name="plural.stage5.1.2"></a><span class="round">②</span>
    lines = file('rules.%s' % language).readlines()          <a name="plural.stage5.1.3"></a><span class="round">③</span>
    patterns = map(string.split, lines)                      <a name="plural.stage5.1.4"></a><span class="round">④</span>
    rules = map(buildRule, patterns)                         <a name="plural.stage5.1.5"></a><span class="round">⑤</span>
    for rule in rules:                                      
        result = rule(noun)                                  <a name="plural.stage5.1.6"></a><span class="round">⑥</span>
        if result: return result                            
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">여기에서도 클로저 테크닉을 사용하고 있지만 (함수 밖에 정의된 변수를 사용하는 함수를 동적으로 구축하는 테크닉), 이제 따로 떨어진 match 함수와 apply 함수를 하나로 조합했습니다.  (이렇게 바꾼 이유는 다음 섹션에서 알려 드리겠습니다.). 이렇게 하면 두  개의 함수를 가진 것과 똑 같은 일을 달성할 수 있지만 다르게 불러야 할 필요가 있습니다. 이에 관해서는 잠시뒤에 알려 드리겠습니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">이제 <tt class="function">plural</tt> 함수는 <tt class="varname">language</tt>라는 선택적인 두 번째 매개변수를 받습니다. 이 매개변수는 <tt class="literal">en</tt>이 기본값입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="varname">language</tt> 매개변수를 사용하여 파일이름을 구성하고, 그 파일을 열어 내용을 리스트로 읽어들입니다. <tt class="varname">language</tt>가 <tt class="literal">en</tt>이면 <tt class="filename">rules.en</tt> 파일을 열고, 전체 내용을 읽어, 줄 단위로 분해하여 리스트로 돌려줍니다. 파일의 각 줄은 리스트의 원소 하나에 해당합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.4"><span class="round">④</span></a> 
                           </td>
                           <td valign="top" align="left">보셨다시피, 파일의 각 줄은 실제로 세 가지 값이 있습니다. 그러나 각 값은 공백으로 분리됩니다 (탭이든 공간문자이든, 아무 차이가 없습니다). <tt class="function">string.split</tt> 함수를 이 리스트 위에 짝지으면 새로운 리스트가 탄생합니다. 이 리스트에서 각 원소는 세 개의 문자열로 구성된 터플입니다. 그래서 <tt class="literal">[sxz]$ $ es</tt>와 같은 줄은 <tt class="literal">('[sxz]$', '$', 'es')</tt> 터플로 분해됩니다. 이는 <tt class="varname">patterns</tt>가 터플 리스트가 된다는 뜻이며, 즉 <a href="#plural.stage4" title="17.5.&nbsp;plural.py, stage 4">단계 4</a>에 하드-코드한 것과 같이 말입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.5"><span class="round">⑤</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="varname">patterns</tt>가 터플 리스트라면 <tt class="varname">rules</tt>는 <tt class="function">buildRule</tt>를 호출할 때마다 동적으로 생성된 함수 리스트가 됩니다. <tt class="function">buildRule(('[sxz]$', '$', 'es'))</tt>를 호출하면 한 개의 매개변수 <tt class="varname">word</tt>를 받는 함수를 돌려줍니다. 이렇게 돌려받은 함수를 호출하면 <tt class="literal">re.search('[sxz]$', word)와 re.sub('$', 'es', word)</tt>가 실행됩니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage5.1.6"><span class="round">⑥</span></a> 
                           </td>
                           <td valign="top" align="left">이제 match 함수와 apply 함수를 조합하였으므로, 다른 방식으로 호출해야 합니다. 그냥 함수를 호출하고, 무언가 돌려주면 그것이 바로 복수형입니다; 아무것도 돌려주지 않으면 (<tt class="literal">None</tt>), 그 규칙이 부합하지 않은 것이고 또다른 규칙을 시도할 필요가 있습니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>그래서 여기에서 개선된 점은 복수화 규칙을 외부 파일로 완전히 분리해 넣었다는 것입니다. 그 파일을 코드와 따로 유지관리할 수 있을 뿐 아니라 같은  <tt class="function">plural</tt> 함수라도 <tt class="varname">language</tt> 매개변수에 근거하여 서로 다른 규칙 파일을 사용할 수 있도록 이름짓기 체계를 설정하였습니다.
               </p>
               <p>여기에서 단점은 <tt class="function">plural</tt> 함수를 호출할 때마다 파일을 읽는다는 것입니다. &#8220;<span class="quote">독자에게 연습문제로 남긴다</span>&#8221;라는 문구 없이도 이 책을 집필할 수 있을 것이라고 생각했었습니다. 그러나, 여기에 숙제를 남깁니다: 규칙 파일이 호출과 호출 사이에 바뀌면 자동으로 재갱신되는 언어-종속적 규칙 파일을 위한 캐시 매커니즘을 구축하는 일을 <span class="emphasis"><em>독자 여러분께 숙제로 남겨 드리겠습니다</em></span>.  재미있게 즐겨 보세요.
               </p>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.stage6"></a>17.7.&nbsp;<tt class="filename">plural.py</tt>, 6 단계
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>이제 발생자에 관하여 언급할 준비가 되었습니다.</p>
               </div>
               <div class="example"><a name="d0e38279"></a><h3 class="title">예제&nbsp;17.17.&nbsp;<tt class="filename">plural6.py</tt></h3><pre class="programlisting">
import re

def rules(language):                                                                 
    for line in file('rules.%s' % language):                                         
        pattern, search, replace = line.split()                                      
        yield lambda word: re.search(pattern, word) and re.sub(search, replace, word)

def plural(noun, language='en'):      
    for applyRule in rules(language): 
        result = applyRule(noun)      
        if result: return result      
</pre></div>
               <p>이는 발생자라고 부르는 테크닉을 사용합니다. 먼저 간단한 예제를 보여 드리고 나서 설명해 드리겠습니다.</p>
               <div class="example"><a name="plural.introducing.generators"></a><h3 class="title">예제&nbsp;17.18.&nbsp;발생자 소개</h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">def make_counter(x):</span>
<tt class="prompt">...     </tt><span class="userinput">print 'entering make_counter'</span>
<tt class="prompt">...     </tt><span class="userinput">while 1:</span>
<tt class="prompt">...     </tt><span class="userinput">    yield x</span>           <a name="plural.stage6.2.1"></a><span class="round">①</span>
<tt class="prompt">...     </tt><span class="userinput">    print 'incrementing x'</span>
<tt class="prompt">...     </tt><span class="userinput">    x = x + 1</span>
<tt class="prompt">...     </tt>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">counter = make_counter(2)</span> <a name="plural.stage6.2.2"></a><span class="round">②</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">counter</span>                   <a name="plural.stage6.2.3"></a><span class="round">③</span>
<span class="computeroutput">&lt;generator object at 0x001C9C10&gt;</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">counter.next()</span>            <a name="plural.stage6.2.4"></a><span class="round">④</span>
<span class="computeroutput">entering make_counter
2</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">counter.next()</span>            <a name="plural.stage6.2.5"></a><span class="round">⑤</span>
<span class="computeroutput">incrementing x
3</span>
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">counter.next()</span>            <a name="plural.stage6.2.6"></a><span class="round">⑥</span>
<span class="computeroutput">incrementing x
4</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">yield</tt> 키워드가 <tt class="function">make_counter</tt>에 있다는 것은 이 함수가 보통 함수가 아니라는 뜻입니다. 이 함수는 특별한 함수로서 한 번에 값을 하나씩 발생시킵니다. 이를 재개가능한 함수라고 생각해도 좋습니다. 호출하면 발생자를 돌려주는데 <tt class="varname">x</tt>의 값을 연속적으로 발생시키는데 사용됩니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">make_counter</tt> 발생자의 실체를 만들려면 그냥 다른 함수처럼 호출하면 됩니다. 이는 실제로 함수 코드를 실행하지 않는다는 것을 주목하세요. 이 사실을 알 수 있는 이유는 <tt class="function">make_counter</tt>의 첫 줄이 <tt class="function">print</tt> 서술문인데, 지금까지 아무것도 출력되지 않았기 때문입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">make_counter</tt> 함수는 발생자 객체를 돌려줍니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.4"><span class="round">④</span></a> 
                           </td>
                           <td valign="top" align="left">발생자 객체에 <tt class="function">next()</tt> 메쏘드를 처음 호출하면 <tt class="function">make_counter</tt>의 코드가 첫 <tt class="literal">yield</tt> 서술문까지 실행되고, 양보된 값을 돌려줍니다. 이 경우, 그 값은 <tt class="literal">2</tt>인데, 원래 <tt class="function">make_counter(2)</tt> 호출해서 발생자를 만들었기 때문입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.5"><span class="round">⑤</span></a> 
                           </td>
                           <td valign="top" align="left">반복해서 <tt class="function">next()</tt>를 그 발생자 객체에 요청하면 <span class="emphasis"><em>떠났던 바로 그 곳에서 재개되고</em></span> 다음 <tt class="literal">yield</tt> 서술문을 만날 때가지 계속됩니다. 실행을 기다리는 다음 코드는 <tt class="function">print</tt> 서술문인데, <tt class="literal">incrementing x</tt>를 인쇄합니다. 그 다음에 <tt class="literal">x = x + 1</tt> 서술문이 오고 실제로 증가시킵니다.  
						   
						   다음 다시 <tt class="literal">while</tt> 회돌이를 돌고, 제일 먼저 하는 일은 <tt class="literal">yield x</tt>인데, 이는 <tt class="varname">x</tt>의 현재 값 (지금은 3)을 돌려줍니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.2.6"><span class="round">⑥</span></a> 
                           </td>
                           <td valign="top" align="left">두 번째로 <tt class="function">counter.next()</tt>를 호출하면 다시 같은 일을 합니다. 그러나 이 번에는 <tt class="varname">x</tt>가 <tt class="literal">4</tt>입니다. 등등. <tt class="function">make_counter</tt>는 무한 회돌이를 설정하기 때문에, 이론적으로 무한히 이렇게 할 수 있으며, 계속해서 <tt class="varname">x</tt>를 증가시키고 값을 뱉아 냅니다. 그러나 대신에 좀 더 생산적으로 발생자를 사용하는 법을 살펴보겠습니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <div class="example"><a name="plural.fib.example"></a><h3 class="title">예제&nbsp;17.19.&nbsp;재귀 대신 발생자를 사용하기</h3><pre class="programlisting">
def fibonacci(max):
    a, b = 0, 1       <a name="plural.stage6.3.1"></a><span class="round">①</span>
    while a &lt; max:
        yield a       <a name="plural.stage6.3.2"></a><span class="round">②</span>
        a, b = b, a+b <a name="plural.stage6.3.3"></a><span class="round">③</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.3.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left">피보나치(Fibonacci) 수열은 앞의 두 숫자를 더한 숫자로 구성된 수열입니다. <tt class="constant">0</tt>과 <tt class="constant">1</tt>에서 시작하여, 처음에는 서서히, 점점 더 빠르게 증가합니다. 이 수열을 시작하려면 두 개의 변수가 필요합니다: <tt class="varname">a</tt>는 <tt class="constant">0</tt>에서 시작하고, <tt class="varname">b</tt>는 <tt class="constant">1</tt>에서 시작합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.3.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="varname">a</tt>는 수열에서 현재 숫자입니다. 그래서 그것을 양보합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.3.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="varname">b</tt>는 수열에서 다음 숫자입니다. 그래서 그것을 <tt class="varname">a</tt>에 할당하고, 또한 나중에 사용하려고 다음 값을 (<tt class="literal">a+b</tt>) 계산해서 그것을 <tt class="varname">b</tt>에 할당합니다. 이는 병행적으로 일어남을 주목하세요; <tt class="varname">a</tt>가 <tt class="literal">3</tt>이고 <tt class="varname">b</tt>가 <tt class="literal">5</tt>인 경우, <tt class="literal">a, b = b, a+b</tt>는 <tt class="varname">a</tt>에 <tt class="literal">5</tt>가 (<tt class="varname">b</tt>의 이전 값) 설정되고 <tt class="varname">b</tt>에 <tt class="literal">8</tt>이 (<tt class="varname">a</tt>와 <tt class="varname">b</tt>의 앞 값의 합) 설정됩니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>그래서 연속적으로 피보나치 숫자를 뱉아내는 함수가 완성되었습니다. 물론, 재귀로도 가능하지만 이런식으로 하는 것이 더 읽기 쉽습니다. 또한, <tt class="literal">for</tt> 회돌이와 더 잘 작동합니다.
               </p>
               <div class="example"><a name="d0e38564"></a><h3 class="title">예제&nbsp;17.20.&nbsp; <tt class="literal">for</tt> 회돌이 안의 발생자
                  </h3><pre class="screen">
<tt class="prompt">&gt;&gt;&gt; </tt><span class="userinput">for n in fibonacci(1000):</span> <a name="plural.stage6.4.1"></a><span class="round">①</span>
<tt class="prompt">...     </tt><span class="userinput">print n,</span>              <a name="plural.stage6.4.2"></a><span class="round">②</span>
<span class="computeroutput">0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987</span>
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.4.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">fibonacci</tt>와 같은 발생자를 <tt class="literal">for</tt> 회돌이에 바로 사용할 수 있습니다.  <tt class="literal">for</tt> 회돌이는 발생자 객체를 만들어 내고 연속적으로 <tt class="function">next()</tt> 메쏘드를 호출하여 값을 얻어서 <tt class="literal">for</tt> 회돌이의 인덱스 변수(<tt class="varname">n</tt>)에 할당합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.4.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">for</tt> 회돌이를 돌 때마다, <tt class="varname">n</tt>은 <tt class="function">fibonacci</tt>의 <tt class="literal">yield</tt> 서술문에서 새로운 값을 얻으며, 그것을 인쇄하기만 하면 됩니다.  <tt class="function">fibonacci</tt> 함수가 숫자를 모두 소비하면 (<tt class="varname">a</tt>가 <tt class="varname">max</tt>보다 더 커지면 이 경우 <tt class="literal">1000</tt>입니다), 그러면 <tt class="literal">for</tt> 회돌이는 우아하게 종료합니다.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p>좋습니다. 다시 <tt class="function">plural</tt> 함수로 돌아가 어떻게 사용하는지 살펴보겠습니다.
               </p>
               <div class="example"><a name="d0e38646"></a><h3 class="title">예제&nbsp;17.21.&nbsp;동적인 함수를 만들어내는 발생자</h3><pre class="programlisting">
def rules(language):                                                                 
    for line in file('rules.%s' % language):                                          <a name="plural.stage6.5.1"></a><span class="round">①</span>
        pattern, search, replace = line.split()                                       <a name="plural.stage6.5.2"></a><span class="round">②</span>
        yield lambda word: re.search(pattern, word) and re.sub(search, replace, word) <a name="plural.stage6.5.3"></a><span class="round">③</span>

def plural(noun, language='en'):      
    for applyRule in rules(language):  <a name="plural.stage6.5.4"></a><span class="round">④</span>
        result = applyRule(noun)      
        if result: return result      
</pre><div class="calloutlist">
                     <table border="0" summary="Callout list">
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.5.1"><span class="round">①</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="literal">for line in file(...)</tt>는 파일로부터 줄을, 한 번에 한 줄씩 읽는 상용구입니다. 이것이 작동하는 이유는 <span class="emphasis"><em><tt class="function">file</tt>이 실제로는 발생자를 돌려주기 때문인데</em></span>, 이 발생자의 <tt class="function">next()</tt> 메쏘드는 파일의 다음 줄을 돌려줍니다. 정말 멋집니다. 생각만 해도 감동의 눈물이 납니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.5.2"><span class="round">②</span></a> 
                           </td>
                           <td valign="top" align="left">여기에서 마법은 전혀 없습니다. 기억하세요. 규칙 파일에서 줄은 세 개의 값을 공백으로 나누어 보유합니다. 그래서 <tt class="literal">line.split()</tt>은 3개의 값으로 구성된 터플 하나를 돌려주고, 그 값을 3개의 지역 변수에 각각 할당합니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.5.3"><span class="round">③</span></a> 
                           </td>
                           <td valign="top" align="left"><span class="emphasis"><em>그리고 양보합니다.</em></span>  무엇을 양보합니까? 함수를 양보합니다. 람다(<tt class="literal">lambda</tt>)를 사용하여 동적으로 구축된 이 함수는 실제로는 클로저(closure)입니다 (지역 변수인 <tt class="varname">pattern</tt>과 <tt class="varname">search</tt> 그리고 <tt class="varname">replace</tt>를 상수로 사용합니다). 다시 말해, <tt class="function">rules</tt>는 규칙 함수를 뱉아 내는 발생자입니다.
                           </td>
                        </tr>
                        <tr>
                           <td width="12" valign="top" align="left"><a href="#plural.stage6.5.4"><span class="round">④</span></a> 
                           </td>
                           <td valign="top" align="left"><tt class="function">rules</tt>는 발생자이므로, 직접적으로 <tt class="literal">for</tt> 회돌이에 사용할 수 있습니다. <tt class="literal">for</tt> 회돌이를 처음 돌때, <tt class="function">rules</tt> 함수를 호출하면 규칙 파일을 열고 그의 첫 줄을 읽어서, 규칙 파일에 정의된 첫 규칙을 일치시켜 적용하는 함수를 동적으로 구축하고, 동적으로 구축된 그 함수를 양보합니다. 두 번째로 <tt class="literal">for</tt> 회돌이를 돌 때, <tt class="function">rules</tt>의 떠났던 그 곳에을 찾아서 (그 곳은 <tt class="literal">for line in file(...)</tt> 회돌이의 중앙이었습니다), 규칙 파일의 두 번째 줄을 읽어서, 규칙 파일에 정의된 두 번째 규칙을 일치시켜 적용하는 또다른 함수를 동적으로 구축하고, 그것을 양보합니다. 등등.
                           </td>
                        </tr>
                     </table>
                  </div>
               </div>
               <p><a href="#plural.stage5" title="17.6.&nbsp;plural.py, stage 5">단계 5</a>에서 얻은 것은 무엇인가?  5 단계에서, 전체 규칙 파일을 읽어서 가능한 모든 규칙 리스트를 구축했습니다. 심지어 첫 규칙을 시도해 보기도 전에 말입니다. 이제 발생자를 사용하면 그 모든 것들을 게으르게 처리할 수 있습니다: 첫 규칙을 열어 일어보고 시도할 함수를 만듭니다. 그러나 그것이 작동한다면 나머지 파일을 읽지 않아도 되며 다른 함수는 만들지 않아도 됩니다.
               </p>
               <div class="itemizedlist">
                  <h3 class="title">더 읽어야 할 것</h3>
                  <ul>
                     <li><a href="http://www.python.org/peps/pep-0255.html">PEP 255</a>에 발생자가 정의되어 있다.
                     </li>
                     <li><a href="http://www.activestate.com/ASPN/Python/Cookbook/" title="growing archive of annotated code samples"><span class="application">파이썬</span> 요리책</a>에는 <a href="http://www.google.com/search?q=generators+cookbook+site:aspn.activestate.com">발생자 예제가 </a> 많다.
                     </li>
                  </ul>
               </div>
            </div>
            <div class="section" lang="en">
               <div class="titlepage">
                  <div>
                     <div>
                        <h2 class="title"><a name="plural.summary"></a>17.8.&nbsp;요약
                        </h2>
                     </div>
                  </div>
                  <div></div>
               </div>
               <div class="abstract">
                  <p>이 장에서는 여러 다양한 고급 테크닉을 살펴보았습니다. 모두가 아무 곳에나 적절한 것은 아닙니다.</p>
               </div>
               <p>이제 다음과 같은 일들을 편안하게 할 수 있어야 합니다:</p>
               <div class="itemizedlist">
                  <ul>
                     <li><a href="#plural.stage1" title="17.2.&nbsp;plural.py, stage 1">정규 표현식으로 문자열 교체</a>를 수행하기.
                     </li>
                     <li><a href="#plural.stage2" title="17.3.&nbsp;plural.py, stage 2">함수를 객체로 취급하고</a>, 그를 리스트에 저장하며, 변수에 할당하고, 그리고 그런 변수를 통하여 호출하기.
                     </li>
                     <li><a href="#plural.stage3" title="17.4.&nbsp;plural.py, stage 3">람다(<tt class="literal">lambda</tt></a>)로 동적 함수를 구축하기.
                     </li>
                     <li>클로저(<a href="#plural.stage4" title="17.5.&nbsp;plural.py, stage 4">closures</a>) 구축하기. 클로저는 주변의 변수를 상수로 가진 동적인 함수입니다.
                     </li>
                     <li>발생자(<a href="#plural.stage6" title="17.7.&nbsp;plural.py, stage 6">generators</a>) 구축하기. 이는 재개가능한 함수로서 점증적인 로직을 수행하고 호출할 때마다 다른 값을 돌려줍니다.
                     </li>
                  </ul>
               </div>
               <p>추상화층을 추가하는 법, 함수를 동적으로 구축하는 법, 클로저 구축하는 법, 그리고 발생자를 사용하는 법을 알면 코드가 더 단순해지고 더 읽기 쉬워지며 그리고 더 유연해집니다. 그러나 나중에 디버그 하기가 더 어려워질 수도 있습니다. 단순함과 파워 사이에 어느 정도로 균형을 유지할지는 여러분에게 달려 있습니다.
               </p>
            </div>
         </div>
<TABLE class='headerOFcontent'>
<TR>
    <TD align="left"><A HREF="chap16.html">☜ 제 16 장 기능적 프로그래밍</A></TD>
    <TD align="center"><A HREF="chap00.html" title="목차로">"""  Dive Into Python  """<BR>다이빙 파이썬</A></TD>
    <TD align="right"><A HREF="chap18.html">제 18 장 수행성능 조율 ☞</A></TD>
</TR>
</TABLE>
    </body>
</html>
